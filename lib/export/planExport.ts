import { TrainingPlan } from '@/types';

export interface ExportOptions {
  format: 'json' | 'csv' | 'ical' | 'text';
  includeCompleted?: boolean;
  includeNotes?: boolean;
}

export class PlanExporter {
  /**
   * Export a training plan in the specified format
   */
  static export(plan: TrainingPlan, options: ExportOptions): string {
    switch (options.format) {
      case 'json':
        return this.exportJSON(plan);
      case 'csv':
        return this.exportCSV(plan, options);
      case 'ical':
        return this.exportICal(plan);
      case 'text':
        return this.exportText(plan, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }

  /**
   * Download the exported plan as a file
   */
  static download(plan: TrainingPlan, options: ExportOptions): void {
    const content = this.export(plan, options);
    const filename = this.generateFilename(plan, options.format);
    const mimeType = this.getMimeType(options.format);

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();

    URL.revokeObjectURL(url);
  }

  /**
   * Export as JSON (full plan data)
   */
  private static exportJSON(plan: TrainingPlan): string {
    return JSON.stringify(plan, null, 2);
  }

  /**
   * Export as CSV (workout data)
   */
  private static exportCSV(plan: TrainingPlan, options: ExportOptions): string {
    const headers = [
      'Week',
      'Day',
      'Date',
      'Workout Type',
      'Name',
      'Description',
      'Distance (mi)',
      'Duration (min)',
      'Target Pace',
      'Effort Level'
    ];

    if (options.includeNotes) {
      headers.push('Notes');
    }

    if (options.includeCompleted) {
      headers.push('Completed');
    }

    const rows = [headers.join(',')];

    plan.weeks.forEach(week => {
      week.workouts.forEach(workout => {
        const row = [
          week.weekNumber.toString(),
          workout.day.toString(),
          workout.date || '',
          workout.type,
          `"${workout.name}"`,
          `"${workout.description}"`,
          workout.distance?.toFixed(1) || '',
          workout.duration?.toString() || '',
          workout.targetPace || '',
          workout.effortLevel.toString()
        ];

        if (options.includeNotes) {
          row.push(`"${workout.notes || ''}"`);
        }

        if (options.includeCompleted) {
          row.push(workout.completed ? 'Yes' : 'No');
        }

        rows.push(row.join(','));
      });
    });

    return rows.join('\n');
  }

  /**
   * Export as iCalendar format
   */
  private static exportICal(plan: TrainingPlan): string {
    const lines = [
      'BEGIN:VCALENDAR',
      'VERSION:2.0',
      'PRODID:-//bonk.ai//Training Plan//EN',
      'CALSCALE:GREGORIAN',
      'METHOD:PUBLISH',
      `X-WR-CALNAME:${this.formatRaceDistance(plan.raceDistance)} Training Plan`,
      'X-WR-CALDESC:AI-generated training plan from bonk.ai'
    ];

    plan.weeks.forEach(week => {
      week.workouts.forEach(workout => {
        if (workout.type !== 'rest') {
          const startDate = this.formatDateForICal(workout.date);
          const uid = `workout-${plan.id}-${week.weekNumber}-${workout.day}@bonk.ai`;

          lines.push(
            'BEGIN:VEVENT',
            `UID:${uid}`,
            `DTSTART:${startDate}`,
            `DTEND:${startDate}`,
            `SUMMARY:${workout.name}`,
            `DESCRIPTION:${workout.description}${workout.targetPace ? ` (Pace: ${workout.targetPace})` : ''}${workout.notes ? `\\n\\nNotes: ${workout.notes}` : ''}`,
            `CATEGORIES:Running,Training`,
            'STATUS:CONFIRMED',
            'TRANSP:TRANSPARENT',
            'END:VEVENT'
          );
        }
      });
    });

    lines.push('END:VCALENDAR');
    return lines.join('\r\n');
  }

  /**
   * Export as readable text format
   */
  private static exportText(plan: TrainingPlan, options: ExportOptions): string {
    let text = `${this.formatRaceDistance(plan.raceDistance)} TRAINING PLAN\n`;
    text += `Generated by bonk.ai on ${new Date(plan.generatedAt).toLocaleDateString()}\n\n`;

    if (plan.targetTime) {
      text += `Target Time: ${plan.targetTime}\n`;
    }

    text += `Total Weeks: ${plan.summary.totalWeeks}\n`;
    text += `Peak Weekly Mileage: ${plan.summary.peakWeeklyMileage} miles\n\n`;

    if (plan.summary.paceRecommendations) {
      text += 'PACE GUIDE:\n';
      Object.entries(plan.summary.paceRecommendations).forEach(([type, pace]) => {
        text += `${type.charAt(0).toUpperCase() + type.slice(1)}: ${pace}\n`;
      });
      text += '\n';
    }

    text += plan.summary.description + '\n\n';

    text += '='.repeat(50) + '\n\n';

    plan.weeks.forEach(week => {
      text += `WEEK ${week.weekNumber}: ${week.theme.toUpperCase()}\n`;
      text += `Total Distance: ${week.totalDistance.toFixed(1)} miles\n`;
      
      if (week.description) {
        text += `${week.description}\n`;
      }
      
      if (week.keyWorkout) {
        text += `Key Workout: ${week.keyWorkout}\n`;
      }
      
      text += '\n';

      week.workouts.forEach(workout => {
        text += `  Day ${workout.day} (${this.getDayName(workout.day)}): ${workout.name}\n`;
        text += `    Type: ${workout.type.charAt(0).toUpperCase() + workout.type.slice(1)}\n`;
        text += `    ${workout.description}\n`;
        
        if (workout.distance) {
          text += `    Distance: ${workout.distance.toFixed(1)} miles\n`;
        }
        
        if (workout.duration) {
          text += `    Duration: ${workout.duration} minutes\n`;
        }
        
        if (workout.targetPace) {
          text += `    Target Pace: ${workout.targetPace}\n`;
        }
        
        text += `    Effort Level: ${workout.effortLevel}/5\n`;
        
        if (options.includeNotes && workout.notes) {
          text += `    Notes: ${workout.notes}\n`;
        }
        
        if (options.includeCompleted) {
          text += `    Completed: ${workout.completed ? 'Yes' : 'No'}\n`;
        }
        
        text += '\n';
      });

      text += '-'.repeat(30) + '\n\n';
    });

    return text;
  }

  /**
   * Generate appropriate filename for export
   */
  private static generateFilename(plan: TrainingPlan, format: string): string {
    const distance = this.formatRaceDistance(plan.raceDistance).replace(/\s+/g, '');
    const date = new Date(plan.generatedAt).toISOString().split('T')[0];
    const extension = this.getFileExtension(format);
    
    return `${distance}_TrainingPlan_${date}.${extension}`;
  }

  /**
   * Get file extension for format
   */
  private static getFileExtension(format: string): string {
    switch (format) {
      case 'json': return 'json';
      case 'csv': return 'csv';
      case 'ical': return 'ics';
      case 'text': return 'txt';
      default: return 'txt';
    }
  }

  /**
   * Get MIME type for format
   */
  private static getMimeType(format: string): string {
    switch (format) {
      case 'json': return 'application/json';
      case 'csv': return 'text/csv';
      case 'ical': return 'text/calendar';
      case 'text': return 'text/plain';
      default: return 'text/plain';
    }
  }

  /**
   * Format race distance for display
   */
  private static formatRaceDistance(distance: string): string {
    switch (distance) {
      case '5k': return '5K';
      case '10k': return '10K';
      case 'half': return 'Half Marathon';
      case 'marathon': return 'Marathon';
      default: return distance.toUpperCase();
    }
  }

  /**
   * Format date for iCalendar
   */
  private static formatDateForICal(dateString?: string): string {
    if (!dateString) {
      return new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    }
    
    const date = new Date(dateString);
    return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
  }

  /**
   * Get day name from day number
   */
  private static getDayName(dayNumber: number): string {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[dayNumber - 1] || `Day ${dayNumber}`;
  }

  /**
   * Generate shareable URL for plan
   */
  static generateShareableUrl(planId: string): string {
    const baseUrl = typeof window !== 'undefined' ? window.location.origin : 'https://bonk.ai';
    return `${baseUrl}/plans/${planId}`;
  }

  /**
   * Copy plan to clipboard as text
   */
  static async copyToClipboard(plan: TrainingPlan): Promise<void> {
    const text = this.exportText(plan, { 
      format: 'text',
      includeNotes: true,
      includeCompleted: false 
    });

    if (navigator.clipboard) {
      await navigator.clipboard.writeText(text);
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
    }
  }
}